{"version":3,"names":[],"mappings":"","sources":["smooth-scroll.js"],"sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\n// SmoothScroll for websites v1.4.0 (Balazs Galambosi)\n// http://www.smoothscroll.net/\n//\n// Licensed under the terms of the MIT license.\n//\n// You may use it in your theme if you credit me.\n// It is also free to use on any individual website.\n//\n// Exception:\n// The only restriction is to not publish any \n// extension for browsers or native application\n// without getting a written permission first.\n//\n\n(function () {\n\n    // Scroll Variables (tweakable)\n    var defaultOptions = {\n\n        // Scrolling Core\n        frameRate: 150, // [Hz]\n        animationTime: 400, // [ms]\n        stepSize: 100, // [px]\n\n        // Pulse (less tweakable)\n        // ratio of \"tail\" to \"acceleration\"\n        pulseAlgorithm: true,\n        pulseScale: 4,\n        pulseNormalize: 1,\n\n        // Acceleration\n        accelerationDelta: 50, // 50\n        accelerationMax: 3, // 3\n\n        // Keyboard Settings\n        keyboardSupport: true, // option\n        arrowScroll: 50, // [px]\n\n        // Other\n        touchpadSupport: false, // ignore touchpad by default\n        fixedBackground: true,\n        excluded: ''\n    };\n\n    var options = defaultOptions;\n\n    // Other Variables\n    var isExcluded = false;\n    var isFrame = false;\n    var direction = { x: 0, y: 0 };\n    var initDone = false;\n    var root = document.documentElement;\n    var activeElement;\n    var observer;\n    var refreshSize;\n    var deltaBuffer = [];\n    var isMac = /^Mac/.test(navigator.platform);\n\n    var key = { left: 37, up: 38, right: 39, down: 40, spacebar: 32,\n        pageup: 33, pagedown: 34, end: 35, home: 36 };\n\n    /***********************************************\n     * INITIALIZE\n     ***********************************************/\n\n    /**\n     * Tests if smooth scrolling is allowed. Shuts down everything if not.\n     */\n    function initTest() {\n        if (options.keyboardSupport) {\n            addEvent('keydown', keydown);\n        }\n    }\n\n    /**\n     * Sets up scrolls array, determines if frames are involved.\n     */\n    function init() {\n\n        if (initDone || !document.body) return;\n\n        initDone = true;\n\n        var body = document.body;\n        var html = document.documentElement;\n        var windowHeight = window.innerHeight;\n        var scrollHeight = body.scrollHeight;\n\n        // check compat mode for root element\n        root = document.compatMode.indexOf('CSS') >= 0 ? html : body;\n        activeElement = body;\n\n        initTest();\n\n        // Checks if this script is running in a frame\n        if (top != self) {\n            isFrame = true;\n        }\n\n        /**\n         * Please duplicate this radar for a Safari fix! \n         * rdar://22376037\n         * https://openradar.appspot.com/radar?id=4965070979203072\n         * \n         * Only applies to Safari now, Chrome fixed it in v45:\n         * This fixes a bug where the areas left and right to \n         * the content does not trigger the onmousewheel event\n         * on some pages. e.g.: html, body { height: 100% }\n         */\n        else if (scrollHeight > windowHeight && (body.offsetHeight <= windowHeight || html.offsetHeight <= windowHeight)) {\n\n                var fullPageElem = document.createElement('div');\n                fullPageElem.style.cssText = 'position:absolute; z-index:-10000; ' + 'top:0; left:0; right:0; height:' + root.scrollHeight + 'px';\n                document.body.appendChild(fullPageElem);\n\n                // DOM changed (throttled) to fix height\n                var pendingRefresh;\n                refreshSize = function refreshSize() {\n                    if (pendingRefresh) return; // could also be: clearTimeout(pendingRefresh);\n                    pendingRefresh = setTimeout(function () {\n                        if (isExcluded) return; // could be running after cleanup\n                        fullPageElem.style.height = '0';\n                        fullPageElem.style.height = root.scrollHeight + 'px';\n                        pendingRefresh = null;\n                    }, 500); // act rarely to stay fast\n                };\n\n                setTimeout(refreshSize, 10);\n\n                addEvent('resize', refreshSize);\n\n                // TODO: attributeFilter?\n                var config = {\n                    attributes: true,\n                    childList: true,\n                    characterData: false\n                    // subtree: true\n                };\n\n                observer = new MutationObserver(refreshSize);\n                observer.observe(body, config);\n\n                if (root.offsetHeight <= windowHeight) {\n                    var clearfix = document.createElement('div');\n                    clearfix.style.clear = 'both';\n                    body.appendChild(clearfix);\n                }\n            }\n\n        // disable fixed background\n        if (!options.fixedBackground && !isExcluded) {\n            body.style.backgroundAttachment = 'scroll';\n            html.style.backgroundAttachment = 'scroll';\n        }\n    }\n\n    /**\n     * Removes event listeners and other traces left on the page.\n     */\n    function cleanup() {\n        observer && observer.disconnect();\n        removeEvent(wheelEvent, wheel);\n        removeEvent('mousedown', mousedown);\n        removeEvent('keydown', keydown);\n        removeEvent('resize', refreshSize);\n        removeEvent('load', init);\n    }\n\n    /************************************************\n     * SCROLLING \n     ************************************************/\n\n    var que = [];\n    var pending = false;\n    var lastScroll = Date.now();\n\n    /**\n     * Pushes scroll actions to the scrolling queue.\n     */\n    function scrollArray(elem, left, top) {\n\n        directionCheck(left, top);\n\n        if (options.accelerationMax != 1) {\n            var now = Date.now();\n            var elapsed = now - lastScroll;\n            if (elapsed < options.accelerationDelta) {\n                var factor = (1 + 50 / elapsed) / 2;\n                if (factor > 1) {\n                    factor = Math.min(factor, options.accelerationMax);\n                    left *= factor;\n                    top *= factor;\n                }\n            }\n            lastScroll = Date.now();\n        }\n\n        // push a scroll command\n        que.push({\n            x: left,\n            y: top,\n            lastX: left < 0 ? 0.99 : -0.99,\n            lastY: top < 0 ? 0.99 : -0.99,\n            start: Date.now()\n        });\n\n        // don't act if there's a pending queue\n        if (pending) {\n            return;\n        }\n\n        var scrollWindow = elem === document.body;\n\n        var step = function step(time) {\n\n            var now = Date.now();\n            var scrollX = 0;\n            var scrollY = 0;\n\n            for (var i = 0; i < que.length; i++) {\n\n                var item = que[i];\n                var elapsed = now - item.start;\n                var finished = elapsed >= options.animationTime;\n\n                // scroll position: [0, 1]\n                var position = finished ? 1 : elapsed / options.animationTime;\n\n                // easing [optional]\n                if (options.pulseAlgorithm) {\n                    position = pulse(position);\n                }\n\n                // only need the difference\n                var x = item.x * position - item.lastX >> 0;\n                var y = item.y * position - item.lastY >> 0;\n\n                // add this to the total scrolling\n                scrollX += x;\n                scrollY += y;\n\n                // update last values\n                item.lastX += x;\n                item.lastY += y;\n\n                // delete and step back if it's over\n                if (finished) {\n                    que.splice(i, 1);i--;\n                }\n            }\n\n            // scroll left and top\n            if (scrollWindow) {\n                window.scrollBy(scrollX, scrollY);\n            } else {\n                if (scrollX) elem.scrollLeft += scrollX;\n                if (scrollY) elem.scrollTop += scrollY;\n            }\n\n            // clean up if there's nothing left to do\n            if (!left && !top) {\n                que = [];\n            }\n\n            if (que.length) {\n                requestFrame(step, elem, 1000 / options.frameRate + 1);\n            } else {\n                pending = false;\n            }\n        };\n\n        // start a new queue of actions\n        requestFrame(step, elem, 0);\n        pending = true;\n    }\n\n    /***********************************************\n     * EVENTS\n     ***********************************************/\n\n    /**\n     * Mouse wheel handler.\n     * @param {Object} event\n     */\n    function wheel(event) {\n\n        if (!initDone) {\n            init();\n        }\n\n        var target = event.target;\n        var overflowing = overflowingAncestor(target);\n\n        // use default if there's no overflowing\n        // element or default action is prevented  \n        // or it's a zooming event with CTRL\n        if (!overflowing || event.defaultPrevented || event.ctrlKey) {\n            return true;\n        }\n\n        // leave embedded content alone (flash & pdf)\n        if (isNodeName(activeElement, 'embed') || isNodeName(target, 'embed') && /\\.pdf/i.test(target.src) || isNodeName(activeElement, 'object')) {\n            return true;\n        }\n\n        var deltaX = -event.wheelDeltaX || event.deltaX || 0;\n        var deltaY = -event.wheelDeltaY || event.deltaY || 0;\n\n        if (isMac) {\n            if (event.wheelDeltaX && isDivisible(event.wheelDeltaX, 120)) {\n                deltaX = -120 * (event.wheelDeltaX / Math.abs(event.wheelDeltaX));\n            }\n            if (event.wheelDeltaY && isDivisible(event.wheelDeltaY, 120)) {\n                deltaY = -120 * (event.wheelDeltaY / Math.abs(event.wheelDeltaY));\n            }\n        }\n\n        // use wheelDelta if deltaX/Y is not available\n        if (!deltaX && !deltaY) {\n            deltaY = -event.wheelDelta || 0;\n        }\n\n        // line based scrolling (Firefox mostly)\n        if (event.deltaMode === 1) {\n            deltaX *= 40;\n            deltaY *= 40;\n        }\n\n        // check if it's a touchpad scroll that should be ignored\n        if (!options.touchpadSupport && isTouchpad(deltaY)) {\n            return true;\n        }\n\n        // scale by step size\n        // delta is 120 most of the time\n        // synaptics seems to send 1 sometimes\n        if (Math.abs(deltaX) > 1.2) {\n            deltaX *= options.stepSize / 120;\n        }\n        if (Math.abs(deltaY) > 1.2) {\n            deltaY *= options.stepSize / 120;\n        }\n\n        scrollArray(overflowing, deltaX, deltaY);\n        event.preventDefault();\n        scheduleClearCache();\n    }\n\n    /**\n     * Keydown event handler.\n     * @param {Object} event\n     */\n    function keydown(event) {\n\n        var target = event.target;\n        var modifier = event.ctrlKey || event.altKey || event.metaKey || event.shiftKey && event.keyCode !== key.spacebar;\n\n        // our own tracked active element could've been removed from the DOM\n        if (!document.contains(activeElement)) {\n            activeElement = document.activeElement;\n        }\n\n        // do nothing if user is editing text\n        // or using a modifier key (except shift)\n        // or in a dropdown\n        // or inside interactive elements\n        var inputNodeNames = /^(textarea|select|embed|object)$/i;\n        var buttonTypes = /^(button|submit|radio|checkbox|file|color|image)$/i;\n        if (inputNodeNames.test(target.nodeName) || isNodeName(target, 'input') && !buttonTypes.test(target.type) || isNodeName(activeElement, 'video') || isInsideYoutubeVideo(event) || target.isContentEditable || event.defaultPrevented || modifier) {\n            return true;\n        }\n\n        // spacebar should trigger button press\n        if ((isNodeName(target, 'button') || isNodeName(target, 'input') && buttonTypes.test(target.type)) && event.keyCode === key.spacebar) {\n            return true;\n        }\n\n        var shift,\n            x = 0,\n            y = 0;\n        var elem = overflowingAncestor(activeElement);\n        var clientHeight = elem.clientHeight;\n\n        if (elem == document.body) {\n            clientHeight = window.innerHeight;\n        }\n\n        switch (event.keyCode) {\n            case key.up:\n                y = -options.arrowScroll;\n                break;\n            case key.down:\n                y = options.arrowScroll;\n                break;\n            case key.spacebar:\n                // (+ shift)\n                shift = event.shiftKey ? 1 : -1;\n                y = -shift * clientHeight * 0.9;\n                break;\n            case key.pageup:\n                y = -clientHeight * 0.9;\n                break;\n            case key.pagedown:\n                y = clientHeight * 0.9;\n                break;\n            case key.home:\n                y = -elem.scrollTop;\n                break;\n            case key.end:\n                var damt = elem.scrollHeight - elem.scrollTop - clientHeight;\n                y = damt > 0 ? damt + 10 : 0;\n                break;\n            case key.left:\n                x = -options.arrowScroll;\n                break;\n            case key.right:\n                x = options.arrowScroll;\n                break;\n            default:\n                return true; // a key we don't care about\n        }\n\n        scrollArray(elem, x, y);\n        event.preventDefault();\n        scheduleClearCache();\n    }\n\n    /**\n     * Mousedown event only for updating activeElement\n     */\n    function mousedown(event) {\n        activeElement = event.target;\n    }\n\n    /***********************************************\n     * OVERFLOW\n     ***********************************************/\n\n    var uniqueID = function () {\n        var i = 0;\n        return function (el) {\n            return el.uniqueID || (el.uniqueID = i++);\n        };\n    }();\n\n    var cache = {}; // cleared out after a scrolling session\n    var clearCacheTimer;\n\n    //setInterval(function () { cache = {}; }, 10 * 1000);\n\n    function scheduleClearCache() {\n        clearTimeout(clearCacheTimer);\n        clearCacheTimer = setInterval(function () {\n            cache = {};\n        }, 1 * 1000);\n    }\n\n    function setCache(elems, overflowing) {\n        for (var i = elems.length; i--;) {\n            cache[uniqueID(elems[i])] = overflowing;\n        }return overflowing;\n    }\n\n    //  (body)                (root)\n    //         | hidden | visible | scroll |  auto  |\n    // hidden  |   no   |    no   |   YES  |   YES  |\n    // visible |   no   |   YES   |   YES  |   YES  |\n    // scroll  |   no   |   YES   |   YES  |   YES  |\n    // auto    |   no   |   YES   |   YES  |   YES  |\n\n    function overflowingAncestor(el) {\n        var elems = [];\n        var body = document.body;\n        var rootScrollHeight = root.scrollHeight;\n        do {\n            var cached = cache[uniqueID(el)];\n            if (cached) {\n                return setCache(elems, cached);\n            }\n            elems.push(el);\n            if (rootScrollHeight === el.scrollHeight) {\n                var topOverflowsNotHidden = overflowNotHidden(root) && overflowNotHidden(body);\n                var isOverflowCSS = topOverflowsNotHidden || overflowAutoOrScroll(root);\n                if (isFrame && isContentOverflowing(root) || !isFrame && isOverflowCSS) {\n                    return setCache(elems, getScrollRoot());\n                }\n            } else if (isContentOverflowing(el) && overflowAutoOrScroll(el)) {\n                return setCache(elems, el);\n            }\n        } while (el = el.parentElement);\n    }\n\n    function isContentOverflowing(el) {\n        return el.clientHeight + 10 < el.scrollHeight;\n    }\n\n    // typically for <body> and <html>\n    function overflowNotHidden(el) {\n        var overflow = getComputedStyle(el, '').getPropertyValue('overflow-y');\n        return overflow !== 'hidden';\n    }\n\n    // for all other elements\n    function overflowAutoOrScroll(el) {\n        var overflow = getComputedStyle(el, '').getPropertyValue('overflow-y');\n        return overflow === 'scroll' || overflow === 'auto';\n    }\n\n    /***********************************************\n     * HELPERS\n     ***********************************************/\n\n    function addEvent(type, fn) {\n        window.addEventListener(type, fn, false);\n    }\n\n    function removeEvent(type, fn) {\n        window.removeEventListener(type, fn, false);\n    }\n\n    function isNodeName(el, tag) {\n        return (el.nodeName || '').toLowerCase() === tag.toLowerCase();\n    }\n\n    function directionCheck(x, y) {\n        x = x > 0 ? 1 : -1;\n        y = y > 0 ? 1 : -1;\n        if (direction.x !== x || direction.y !== y) {\n            direction.x = x;\n            direction.y = y;\n            que = [];\n            lastScroll = 0;\n        }\n    }\n\n    var deltaBufferTimer;\n\n    if (window.localStorage && localStorage.SS_deltaBuffer) {\n        deltaBuffer = localStorage.SS_deltaBuffer.split(',');\n    }\n\n    function isTouchpad(deltaY) {\n        if (!deltaY) return;\n        if (!deltaBuffer.length) {\n            deltaBuffer = [deltaY, deltaY, deltaY];\n        }\n        deltaY = Math.abs(deltaY);\n        deltaBuffer.push(deltaY);\n        deltaBuffer.shift();\n        clearTimeout(deltaBufferTimer);\n        deltaBufferTimer = setTimeout(function () {\n            if (window.localStorage) {\n                localStorage.SS_deltaBuffer = deltaBuffer.join(',');\n            }\n        }, 1000);\n        return !allDeltasDivisableBy(120) && !allDeltasDivisableBy(100);\n    }\n\n    function isDivisible(n, divisor) {\n        return Math.floor(n / divisor) == n / divisor;\n    }\n\n    function allDeltasDivisableBy(divisor) {\n        return isDivisible(deltaBuffer[0], divisor) && isDivisible(deltaBuffer[1], divisor) && isDivisible(deltaBuffer[2], divisor);\n    }\n\n    function isInsideYoutubeVideo(event) {\n        var elem = event.target;\n        var isControl = false;\n        if (document.URL.indexOf('www.youtube.com/watch') != -1) {\n            do {\n                isControl = elem.classList && elem.classList.contains('html5-video-controls');\n                if (isControl) break;\n            } while (elem = elem.parentNode);\n        }\n        return isControl;\n    }\n\n    var requestFrame = function () {\n        return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function (callback, element, delay) {\n            window.setTimeout(callback, delay || 1000 / 60);\n        };\n    }();\n\n    var MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;\n\n    var getScrollRoot = function () {\n        var SCROLL_ROOT;\n        return function () {\n            if (!SCROLL_ROOT) {\n                var dummy = document.createElement('div');\n                dummy.style.cssText = 'height:10000px;width:1px;';\n                document.body.appendChild(dummy);\n                var bodyScrollTop = document.body.scrollTop;\n                var docElScrollTop = document.documentElement.scrollTop;\n                window.scrollBy(0, 1);\n                if (document.body.scrollTop != bodyScrollTop) SCROLL_ROOT = document.body;else SCROLL_ROOT = document.documentElement;\n                window.scrollBy(0, -1);\n                document.body.removeChild(dummy);\n            }\n            return SCROLL_ROOT;\n        };\n    }();\n\n    /***********************************************\n     * PULSE (by Michael Herf)\n     ***********************************************/\n\n    /**\n     * Viscous fluid with a pulse for part and decay for the rest.\n     * - Applies a fixed force over an interval (a damped acceleration), and\n     * - Lets the exponential bleed away the velocity over a longer interval\n     * - Michael Herf, http://stereopsis.com/stopping/\n     */\n    function pulse_(x) {\n        var val, start, expx;\n        // test\n        x = x * options.pulseScale;\n        if (x < 1) {\n            // acceleartion\n            val = x - (1 - Math.exp(-x));\n        } else {\n            // tail\n            // the previous animation ended here:\n            start = Math.exp(-1);\n            // simple viscous drag\n            x -= 1;\n            expx = 1 - Math.exp(-x);\n            val = start + expx * (1 - start);\n        }\n        return val * options.pulseNormalize;\n    }\n\n    function pulse(x) {\n        if (x >= 1) return 1;\n        if (x <= 0) return 0;\n\n        if (options.pulseNormalize == 1) {\n            options.pulseNormalize /= pulse_(1);\n        }\n        return pulse_(x);\n    }\n\n    /***********************************************\n     * FIRST RUN\n     ***********************************************/\n\n    var userAgent = window.navigator.userAgent;\n    var isEdge = /Edge/.test(userAgent); // thank you MS\n    var isChrome = /chrome/i.test(userAgent) && !isEdge;\n    var isSafari = /safari/i.test(userAgent) && !isEdge;\n    var isMobile = /mobile/i.test(userAgent);\n    var isEnabledForBrowser = (isChrome || isSafari) && !isMobile;\n\n    var wheelEvent;\n    if ('onwheel' in document.createElement('div')) wheelEvent = 'wheel';else if ('onmousewheel' in document.createElement('div')) wheelEvent = 'mousewheel';\n\n    if (wheelEvent && isEnabledForBrowser) {\n        addEvent(wheelEvent, wheel);\n        addEvent('mousedown', mousedown);\n        addEvent('load', init);\n    }\n\n    /***********************************************\n     * PUBLIC INTERFACE\n     ***********************************************/\n\n    function SmoothScroll(optionsToSet) {\n        for (var key in optionsToSet) {\n            if (defaultOptions.hasOwnProperty(key)) options[key] = optionsToSet[key];\n        }\n    }\n    SmoothScroll.destroy = cleanup;\n\n    if (window.SmoothScrollOptions) // async API\n        SmoothScroll(window.SmoothScrollOptions);\n\n    if ('object' == (typeof exports === 'undefined' ? 'undefined' : _typeof(exports))) module.exports = SmoothScroll;else window.SmoothScroll = SmoothScroll;\n})();\n\n},{}]},{},[1]);\n"],"file":"smooth-scroll.js","sourceRoot":"/source/"}