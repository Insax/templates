{"version":3,"names":[],"mappings":"","sources":["jquery.hexagonprogress.js"],"sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n\"use strict\";\n\n/*!\n  Hexagon Progress jQuery Plugin\n  @name jquery.hexagonprogress.js\n  @description Draw animated hexagon progress bars\n  @author Max Lawrence \n  @version 1.2.0\n  @category jQuery plugin\n  @copyright (c) 2015 Max Lawrence (http://www.avirtum.com)\n  @license Licensed under the MIT (http://www.opensource.org/licenses/mit-license.php) license.\n*/\n(function ($) {\n    \"use strict\";\n\n    function HexagonProgress(config) {\n        this.init(config);\n    }\n\n    HexagonProgress.prototype = {\n        //=============================================\n        // Public Section\n        //=============================================\n\n        /**\n         * Size of the hexagon / canvas in pixels. \n         * Number or string ('parent' - minimum width or height of the parent element)\n         * @public\n         * @type {number|string}\n         */\n        size: \"parent\",\n\n        /**\n         * Range. It should be [0.0; 1.0]\n         * @public\n         * @type {number}\n         */\n        value: 0.0,\n\n        /**\n         * Initial angle for 0.0 value in radians\n         * @public\n         * @type {number}\n         */\n        startAngle: Math.PI / 2,\n\n        /**\n         * Width of the line. By default it's auto-calculated as 1/14 of size\n         * @public\n         * @type {number}\n         */\n        lineWidth: null,\n\n        /**\n         * Line cap (\"butt\" \"round\" or \"square\")\n         * Read more: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D.lineCap\n         * @public\n         * @type {string}\n         */\n        lineCap: \"round\",\n\n        /**\n         * On/off clipping mask. It works if background is not null.\n         * @public\n         * @type {boolean}\n         */\n        clip: false,\n\n        /**\n         * Background. You may set it to:\n         *   - solid color:\n         *     - { color: \"#fb141d\" }\n         *     - { color: \"rgba(255, 255, 255, .5)\" }\n         *   - image:\n         *     - { image: \"http://i.imgur.com/HmMu67L.jpg\" }\n         *     - { image: imageObject }\n         * @public\n         */\n        background: null,\n\n        /**\n         * Color of the back border. You may set it to:\n         *   - solid color:\n         *     - { color: \"#fb141d\" }\n         *     - { color: \"rgba(255, 255, 255, .5)\" }\n         * @public\n         */\n        lineBackFill: {\n            color: \"rgba(0, 0, 0, .1)\"\n        },\n\n        /**\n         * Fill of the border. You may set it to:\n         *   - solid color:\n         *     - { color: \"#fb141d\" }\n         *     - { color: \"rgba(255, 255, 255, .5)\" }\n         *   - linear gradient (left to right):\n         *     - { gradient: [\"#fb141d\", \"#fb0c58\"], gradientAngle: Math.PI / 4 }\n         *     - { gradient: [\"red\", \"green\", \"blue\"], gradientDirection: [x0, y0, x1, y1] }\n         *   - image:\n         *     - { image: \"http://i.imgur.com/HmMu67L.jpg\" }\n         *     - { image: imageObject }\n         *     - { color: \"lime\", image: \"http://i.imgur.com/HmMu67L.jpg\" } - color displayed until the image is loaded\n         * @public\n         */\n        lineFrontFill: {\n            gradient: [\"#fb141d\", \"#fb0c58\"]\n        },\n\n        /**\n         * Animation config (see jQuery animations: http://api.jquery.com/animate/)\n         * @public\n         */\n        animation: {\n            duration: 1800,\n            easing: \"hexagonEasing\"\n        },\n\n        /**\n         * Default animation starts at 0.0 and ends at specified `value`. Let's call this direct animation.\n         * @type {number}\n         */\n        animationStartValue: 0.0,\n\n        //=============================================\n        // Protected Section\n        //=============================================\n        /**\n         * @protected\n         */\n        constructor: HexagonProgress,\n\n        /**\n         * Container element. Should be passed into constructor config\n         * @protected\n         * @type {jQuery}\n         */\n        el: null,\n\n        /**\n         * Canvas element. Automatically generated and prepended to the {@link HexagonProgress el}\n         * @protected\n         * @type {HTMLCanvasElement}\n         */\n        canvas: null,\n\n        /**\n         * 2D-context of the {@link HexagonProgress el canvas}\n         * @protected\n         * @type {CanvasRenderingContext2D}\n         */\n        ctx: null,\n\n        /**\n         * Radius of the outer circle. Automatically calculated as {@link HexagonProgress.size / 2}\n         * @protected\n         * @type {number}\n         */\n        outerRadius: 0.0,\n\n        /**\n         * Fill of the line. Automatically calculated, depending on {@link HexagonProgress.lineFrontFill} option\n         * @protected\n         * @type {string|CanvasGradient|CanvasPattern}\n         */\n        lineFill: null,\n\n        /**\n         * Last rendered value\n         * @protected\n         * @type {number}\n         */\n        lastValue: 0.0,\n\n        /**\n         * Coordinates of the hexagon (back)\n         * @protected\n         * @type {array}\n         */\n        coordBack: [],\n\n        /**\n         * Coordinates of the hexagon (front)\n         * @protected\n         * @type {array}\n         */\n        coordFront: [],\n\n        /**\n         * Edges of the hexagon\n         * @protected\n         * @type {array}\n         */\n        edges: [],\n\n        /**\n         * Init/reinit the widget\n         * @param {object}\n         */\n        init: function init(config) {\n            $.extend(this, config);\n            this.initWidget();\n            this.initFill();\n            this.draw();\n        },\n\n        /**\n         * @protected\n         */\n        initWidget: function initWidget() {\n            var canvas = this.canvas = this.canvas || $(\"<canvas>\").prependTo(this.el)[0];\n\n            if (this.size == \"parent\") {\n                var h = $(canvas).parent().outerHeight(),\n                    w = $(canvas).parent().outerWidth();\n                this.size = h > w ? w : h;\n            }\n\n            canvas.width = this.size;\n            canvas.height = this.size;\n            this.ctx = canvas.getContext(\"2d\");\n            this.outerRadius = this.size / 2;\n        },\n\n        /**\n         * This method sets {@link HexagonProgress.coordBack}\n         * @protected\n         */\n        initCoordBack: function initCoordBack() {\n            var r = this.outerRadius,\n                w = this.getLineWidth(),\n                r = r - w / 2,\n                a = r * Math.sqrt(3) / 2,\n                b = r / 2,\n                x_offset = w / 2,\n                y_offset = r - r * Math.sqrt(3) / 2 + w / 2,\n                x0 = b + x_offset,\n                y0 = 0 + y_offset,\n                x1 = x0 + r,\n                y1 = y0 + 0,\n                x2 = x1 + b,\n                y2 = y1 + a,\n                x3 = x2 - b,\n                y3 = y2 + a,\n                x4 = x3 - r,\n                y4 = y3 - 0,\n                x5 = x4 - b,\n                y5 = y4 - a,\n                coord = [{ x: x0, y: y0 }, { x: x1, y: y1 }, { x: x2, y: y2 }, { x: x3, y: y3 }, { x: x4, y: y4 }, { x: x5, y: y5 }, { x: x0, y: y0 }],\n                edges = [{ x: coord[1].x - coord[0].x, y: coord[1].y - coord[0].y }, { x: coord[2].x - coord[1].x, y: coord[2].y - coord[1].y }, { x: coord[3].x - coord[2].x, y: coord[3].y - coord[2].y }, { x: coord[4].x - coord[3].x, y: coord[4].y - coord[3].y }, { x: coord[5].x - coord[4].x, y: coord[5].y - coord[4].y }, { x: coord[0].x - coord[5].x, y: coord[0].y - coord[5].y }];\n\n            this.coordBack = coord;\n            this.edges = edges;\n        },\n\n        /**\n         * This method sets {@link HexagonProgress.coordFront}\n         * @protected\n         */\n        initCoordFront: function initCoordFront(value) {\n            var r = this.outerRadius,\n                w = this.getLineWidth(),\n                a = this.startAngle,\n                aBegin = a * 180 / Math.PI - 60,\n                aBegin = Math.abs(aBegin) > 360 ? aBegin - Math.floor(aBegin / 360) * 360 : aBegin,\n                aBegin = aBegin < 0 ? 360 + aBegin : aBegin,\n                aEnd = aBegin + 360 * value,\n                // value = [0.0,1.0]\n            aEnd = Math.abs(aEnd) > 360 ? aEnd - Math.floor(aEnd / 360) * 360 : aEnd,\n                sectorBegin = Math.floor(aBegin / 60) + 1,\n                sectorEnd = Math.floor(aEnd / 60) + 1,\n                coefBegin = Math.abs((sectorBegin - 1) * 60 - aBegin) / 60,\n                coefEnd = Math.abs((sectorEnd - 1) * 60 - aEnd) / 60,\n                sectorCnt = Math.floor(value / (1 / 6) + coefBegin) + 1,\n                coord = [];\n\n            var sector = sectorBegin,\n                x = this.edges[sector - 1].x * coefBegin + this.coordBack[sector - 1].x,\n                y = this.edges[sector - 1].y * coefBegin + this.coordBack[sector - 1].y;\n            coord.push({ x: x, y: y });\n\n            if (sectorCnt > 1) {\n                for (var i = 1; i <= 6; i++) {\n                    if (sector == sectorEnd && sectorBegin != sectorEnd) {\n                        x = this.edges[sector - 1].x * coefEnd + this.coordBack[sector - 1].x;\n                        y = this.edges[sector - 1].y * coefEnd + this.coordBack[sector - 1].y;\n                        coord.push({ x: x, y: y });\n                        break;\n                    } else {\n                        x = this.coordBack[sector].x;\n                        y = this.coordBack[sector].y;\n                        coord.push({ x: x, y: y });\n                    }\n\n                    sector++;\n                    if (sector > 6) {\n                        sector = 1;\n                    }\n                }\n            }\n\n            if (sector == sectorEnd && sectorBegin == sectorEnd) {\n                x = this.edges[sector - 1].x * coefEnd + this.coordBack[sector - 1].x;\n                y = this.edges[sector - 1].y * coefEnd + this.coordBack[sector - 1].y;\n                coord.push({ x: x, y: y });\n            }\n\n            this.coordFront = coord;\n        },\n\n        /**\n         * This method sets {@link HexagonProgress.lineFill}\n         * It could do this async (on image load)\n         * @protected\n         */\n        initFill: function initFill() {\n            var self = this,\n                ctx = this.ctx;\n\n            function setImageLineFill() {\n                var bg = $(\"<canvas>\")[0];\n                bg.width = self.size;\n                bg.height = self.size;\n                bg.getContext(\"2d\").drawImage(img, 0, 0, self.size, self.size);\n                self.lineFill = self.ctx.createPattern(bg, \"no-repeat\");\n                self.drawFrame(self.lastValue);\n            }\n\n            if (!this.lineFrontFill) {\n                throw Error(\"The lineFrontFill is not specified!\");\n            }\n\n            if (this.lineFrontFill.color) {\n                this.lineFill = this.lineFrontFill.color;\n            }\n\n            if (this.lineFrontFill.gradient) {\n                var gr = this.lineFrontFill.gradient;\n\n                if (gr.length == 1) {\n                    this.lineFill = gr[0];\n                } else if (gr.length > 1) {\n                    var ga = this.lineFrontFill.gradientAngle || 0,\n                        // gradient direction angle; 0 by default\n                    gd = this.lineFrontFill.gradientDirection || [self.size / 2 * (1 - Math.cos(ga)), // x0\n                    self.size / 2 * (1 + Math.sin(ga)), // y0\n                    self.size / 2 * (1 + Math.cos(ga)), // x1\n                    self.size / 2 * (1 - Math.sin(ga)) // y1\n                    ];\n\n                    var lg = ctx.createLinearGradient.apply(ctx, gd);\n\n                    for (var i = 0; i < gr.length; i++) {\n                        var color = gr[i],\n                            pos = i / (gr.length - 1);\n\n                        if ($.isArray(color)) {\n                            pos = color[1];\n                            color = color[0];\n                        }\n\n                        lg.addColorStop(pos, color);\n                    }\n\n                    this.lineFill = lg;\n                }\n            }\n\n            if (this.lineFrontFill.image) {\n                var img;\n\n                if (this.lineFrontFill.image instanceof Image) {\n                    img = this.lineFrontFill.image;\n                } else {\n                    img = new Image();\n                    img.src = this.lineFrontFill.image;\n                }\n\n                if (img.complete) {\n                    setImageLineFill();\n                } else {\n                    img.onload = setImageLineFill;\n                }\n            }\n        },\n\n        /**\n         * @protected\n         */\n        draw: function draw() {\n            if (this.animation) {\n                this.drawAnimated(this.value);\n            } else {\n                this.drawFrame(this.value);\n            }\n        },\n\n        /**\n         * @protected\n         * @param {number}\n         */\n        drawAnimated: function drawAnimated(value) {\n            var self = this,\n                el = this.el,\n                canvas = $(this.canvas);\n\n            // stop previous animation before new \"start\" event is triggered\n            canvas.stop(true, false);\n            el.trigger(\"hexagon-animation-start\");\n\n            canvas.css({ animationProgress: 0 }).animate({ animationProgress: 1 }, $.extend({}, this.animation, {\n                step: function step(animationProgress) {\n                    var stepValue = self.animationStartValue * (1 - animationProgress) + value * animationProgress;\n                    self.drawFrame(stepValue);\n                    el.trigger(\"hexagon-animation-progress\", [animationProgress, stepValue]);\n                }\n            })).promise().always(function () {\n                // trigger on both successful & failure animation end\n                el.trigger(\"hexagon-animation-end\");\n            });\n        },\n\n        /**\n         * @protected\n         * @param {number}\n         */\n        drawFrame: function drawFrame(value) {\n            this.lastValue = value;\n            this.ctx.clearRect(0, 0, this.size, this.size);\n            this.initCoordBack();\n            this.initCoordFront(value);\n\n            if (this.background) {\n                this.drawWithBackground();\n            } else {\n                this.drawBack();\n                this.drawFront();\n            }\n        },\n\n        /** \n         * @protected\n         */\n        checkSupportCompositeMode: function checkSupportCompositeMode(ctx, mode) {\n            var oldMode = ctx.globalCompositeOperation,\n                result = false;\n\n            ctx.globalCompositeOperation = mode;\n            if (ctx.globalCompositeOperation == mode) {\n                result = true;\n            }\n            ctx.globalCompositeOperation = oldMode;\n            return result;\n        },\n\n        /** You should save canvas context before call this function\n         * @protected\n         */\n        makeClipMask: function makeClipMask() {\n            var ctx = this.ctx,\n                w = this.getLineWidth(),\n                outerRadius = this.outerRadius,\n                offset = w / 2;\n\n            this.outerRadius -= offset;\n            this.initCoordBack();\n\n            ctx.beginPath();\n            ctx.moveTo(this.coordBack[0].x + offset, this.coordBack[0].y + offset);\n            for (var i = 0; i < this.coordBack.length; i++) {\n                ctx.lineTo(this.coordBack[i].x + offset, this.coordBack[i].y + offset);\n            }\n            ctx.closePath();\n\n            if (this.checkSupportCompositeMode(ctx, \"destination-in\")) {\n                ctx.globalCompositeOperation = \"destination-in\";\n                ctx.fillStyle = \"#fff\"; //color doesn't matter, but we want full opacity\n                ctx.fill();\n            } else {\n                ctx.clip();\n            }\n\n            this.outerRadius = outerRadius;\n            this.initCoordBack();\n        },\n\n        /**\n         * @protected\n         */\n        drawWithBackground: function drawWithBackground() {\n            var self = this,\n                ctx = this.ctx,\n                w = this.getLineWidth();\n\n            function setImageBackground() {\n                var imgWidth = img.width,\n                    imgHeight = img.height,\n                    percentWidth = self.size / imgWidth,\n                    percentHeight = self.size / imgHeight,\n                    percent = percentHeight > percentWidth ? percentHeight : percentWidth,\n                    newWidth = imgWidth * percent,\n                    newHeight = imgHeight * percent,\n                    offsetWidth = (self.size - newWidth) / 2,\n                    offsetHeight = (self.size - newHeight) / 2;\n\n                ctx.save();\n                if (self.clip) {\n                    if (self.checkSupportCompositeMode(ctx, \"destination-in\")) {\n                        ctx.drawImage(img, 0, 0, img.width, img.height, offsetWidth, offsetHeight, newWidth, newHeight);\n                        self.makeClipMask.call(self);\n                    } else {\n                        self.makeClipMask.call(self);\n                        ctx.drawImage(img, 0, 0, img.width, img.height, offsetWidth, offsetHeight, newWidth, newHeight);\n                    }\n                } else {\n                    ctx.drawImage(img, 0, 0, img.width, img.height, offsetWidth, offsetHeight, newWidth, newHeight);\n                }\n                ctx.restore();\n\n                self.drawBack.call(self);\n                self.drawFront.call(self);\n            };\n\n            function setBackgroundColor() {\n                ctx.beginPath();\n                ctx.rect(0, 0, self.size, self.size);\n                ctx.fillStyle = self.background.color;\n                ctx.fill();\n            }\n\n            if (this.background.color) {\n                ctx.save();\n                if (self.clip) {\n                    if (self.checkSupportCompositeMode(ctx, \"destination-in\")) {\n                        setBackgroundColor();\n                        self.makeClipMask.call(self);\n                    } else {\n                        self.makeClipMask.call(self);\n                        setBackgroundColor();\n                    }\n                } else {\n                    setBackgroundColor();\n                }\n                ctx.restore();\n\n                self.drawBack.call(self);\n                self.drawFront.call(self);\n            }\n\n            if (this.background.image) {\n                var img;\n\n                if (this.background.image instanceof Image) {\n                    img = this.background.image;\n                } else {\n                    img = new Image();\n                    img.src = this.background.image;\n                }\n\n                if (img.complete) {\n                    setImageBackground();\n                } else {\n                    img.onload = setImageBackground;\n                }\n            }\n        },\n\n        /**\n         * @protected\n         */\n        drawBack: function drawBack() {\n            var ctx = this.ctx,\n                w = this.getLineWidth();\n\n            ctx.save();\n            ctx.beginPath();\n            ctx.moveTo(this.coordBack[0].x, this.coordBack[0].y);\n            for (var i = 0; i < this.coordBack.length; i++) {\n                ctx.lineTo(this.coordBack[i].x, this.coordBack[i].y);\n            }\n            ctx.lineWidth = w;\n            ctx.strokeStyle = this.lineBackFill.color;\n            ctx.closePath();\n\n            ctx.stroke();\n            ctx.restore();\n        },\n\n        /**\n         * @protected\n         */\n        drawFront: function drawFront() {\n            if (this.value == 0) {\n                return;\n            }\n\n            var ctx = this.ctx,\n                w = this.getLineWidth();\n\n            ctx.save();\n            ctx.beginPath();\n            ctx.moveTo(this.coordFront[0].x, this.coordFront[0].y);\n            for (var i = 0; i < this.coordFront.length; i++) {\n                ctx.lineTo(this.coordFront[i].x, this.coordFront[i].y);\n            }\n            ctx.lineWidth = w;\n            ctx.strokeStyle = this.lineFill;\n            ctx.lineCap = this.lineCap;\n            ctx.stroke();\n            ctx.restore();\n        },\n\n        /**\n         * @protected\n         * @returns {number}\n         */\n        getLineWidth: function getLineWidth() {\n            return $.isNumeric(this.lineWidth) ? this.lineWidth : this.size / 14;\n        },\n\n        getValue: function getValue() {\n            return this.value;\n        },\n\n        setValue: function setValue(newValue) {\n            if (this.animation) this.animationStartValue = this.lastFrameValue;\n            this.value = newValue;\n            this.draw();\n        }\n    };\n\n    //=============================================\n    // Init jQuery Plugin\n    //=============================================\n    $.hexagonProgress = {\n        // Default options (you may override them)\n        defaults: HexagonProgress.prototype\n    };\n\n    // ease-in-out-cubic\n    $.easing.hexagonEasing = function (x, t, b, c, d) {\n        if ((t /= d / 2) < 1) return c / 2 * t * t * t + b;\n        return c / 2 * ((t -= 2) * t * t + 2) + b;\n    };\n\n    /**\n     * Draw animated hexagon progress bar.\n     *\n     * Appends <canvas> to the element or updates already appended one.\n     *\n     * If animated, throws 3 events:\n     *   - hexagon-animation-start(jqEvent)\n     *   - hexagon-animation-progress(jqEvent, animationProgress, stepValue) - multiple event; (animationProgress: from 0.0 to 1.0; stepValue: from 0.0 to value)\n     *   - hexagon-animation-end(jqEvent)\n     *\n     * @param CfgOrCmd - config object or command name\n     *     Example: { value: 0.75, size: 50, animation: false };\n     *     you may set any public property (see above);\n     *     `animation` may be set to false;\n     *     you may use .hexagonProgress(\"canvas\") to get the canvas\n     *     you may use .hexagonProgress(\"value\", newValue) to dynamically update the value\n     *\n     * @param CmdArgs - some commands (like \"value\") may require an argument\n     */\n    $.fn.hexagonProgress = function (CfgOrCmd, CmdArgs) {\n        var dataName = \"hexagon-progress\",\n            instance = this.data(dataName);\n\n        if (CfgOrCmd == \"canvas\") {\n            if (!instance) {\n                throw Error(\"Calling 'canvas' method on not initialized instance is forbidden\");\n            }\n            return instance.canvas;\n        }\n\n        if (CfgOrCmd == \"value\") {\n            if (!instance) {\n                throw Error(\"Calling 'value' method on not initialized instance is forbidden\");\n            }\n\n            if (typeof CmdArgs == \"undefined\") {\n                return instance.getValue();\n            } else {\n                var newValue = arguments[1];\n                return this.each(function () {\n                    $(this).data(dataName).setValue(newValue);\n                });\n            }\n        }\n\n        return this.each(function () {\n            var el = $(this),\n                instance = el.data(dataName),\n                config = $.isPlainObject(CfgOrCmd) ? CfgOrCmd : {};\n\n            if (instance) {\n                instance.init(config);\n            } else {\n                var initialConfig = $.extend({}, el.data());\n\n                if (typeof initialConfig.lineBackFill == \"string\") {\n                    initialConfig.lineBackFill = JSON.parse(initialConfig.lineBackFill);\n                }\n\n                if (typeof initialConfig.lineFrontFill == \"string\") {\n                    initialConfig.lineFrontFill = JSON.parse(initialConfig.lineFrontFill);\n                }\n\n                if (typeof initialConfig.background == \"string\") {\n                    initialConfig.background = JSON.parse(initialConfig.background);\n                }\n\n                if (typeof initialConfig.animation == \"string\") {\n                    initialConfig.animation = JSON.parse(initialConfig.animation);\n                }\n\n                config = $.extend(initialConfig, config);\n                config.el = el;\n                instance = new HexagonProgress(config);\n                el.data(dataName, instance);\n            }\n        });\n    };\n})(window.jQuery);\n\n},{}]},{},[1]);\n"],"file":"jquery.hexagonprogress.js","sourceRoot":"/source/"}